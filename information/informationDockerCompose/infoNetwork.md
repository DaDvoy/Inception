https://rohanzi.gitlab.io/balberin-clouds/project/composenetworking/ - Сети в Docker Compose;

https://dker.ru/docs/docker-compose/networking-in-compose/ -  Сети в Compose;
 
https://almat.su/zapusk-neskolkih-docker-kontejnerov-v-odnoj-seti/ - ЗАПУСК НЕСКОЛЬКИХ DOCKER КОНТЕЙНЕРОВ В ОДНОЙ СЕТИ;

http://celnet.ru/bridge.php - Network bridge (Сетевой мост);

https://coderoad.ru/56825258/%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D1%80%D0%B5%D0%B6%D0%B8%D0%BC%D0%B0%D0%BC%D0%B8-docker-BRIDGE-%D0%B8-HOST - В чем разница между режимами docker BRIDGE и HOST;

https://linux-notes.org/rabota-s-setju-networking-v-docker/ - Работа с сетью (Networking) в Docker.

# Основная часть:

По умолчанию Compose создает одну сеть для вашего приложения. Каждый контейнер подключается к этой сети и доступен для других контейнеров из этой сети в том числе по имени узла идентичному имени контейнера.

При установке Docker-а автоматически создается три сети под название none, host, bridge. Список можно посмотреть через команду docker network ls.

 - none — у контейнера нет сети, он изолирован, ему сломали ethernet port;

 - host — использовать сеть хоста. Чтобы присоединиться к ним, придется вручную прописать имя сети при запуске docker run —network=host|none.

 - bridge — По умолчанию при создании контейнера, докер присоединяет контейнер к уже существующей сети под названием bridge.

**КАК НАЙТИ КОНТЕЙНЕР В СЕТИ ПО ИМЕНИ:**

Docker умеет автоматически находить ип адреса контейнеров по именам (auto service discover), но для этого нужно использовать пользовательское сетевое окружение или именованное сетевое окружение (user-defined-network).

Создать новую сеть можно командой:

`docker network create busybox-network`

**КАК НАСТРОИТЬ СЕТЬ В DOCKER-COMPOSE:**

networks — описывается используемая сеть, их может быть несколько

 - default — означает что сеть будет использоваться для всех сервисов. Вместо default  можно написать  «my-awesome-network», тогда эту сеть нужно будет указывать явно сервиса. Удобно если к сети нужно подключить только один из сервисов из пяти.

 - name — имя сети

 - external — сеть внешняя, то есть при старте docker-compose будет использовать существующую сеть, а не пытаться создать новую

 - tty — включить терминал при старте. Нужно чтобы запустить процесс в фоне, иначе процесс сразу же завершить выполнение. Аналог команды docker run -ti

**Использование существующей сети**

Если сеть уже создана (например, через Docker CLI), то подключиться к ней можно с использованием опции external:

```
networks:
  default:
    external:
      name: my-pre-existing-network
```

Таким образом вместо создания сети [projectname]_default, Compose подключит приложение к сети my-pre-existing-network.


**Наглядная иерархия параметров в Docker Compose**

Стоит учитывать, что многие параметры в представленном ниже описании конфликтуют, но они были описаны вместе для удоства и понимания иерархии параметров.

```
networks:
# Имя default для реконфигурации стандартной сети для Compose имя сети:
# Типы драйверов: bridge, overlay  
driver: overlay
# attachable работает только в Compose 3.2+
attachable: true
# параметры драйвера (см. документацию драйвера)
driver_opts:
	foo: "bar"
	baz: 1
# Поддержка IPv6 не доступна в Compose 3, только 2.
enable_ipv6: true
# Настройка IPAM конфигурации
ipam:
	# драйвер IPAM заместо default если нужно
	driver: default
	# Конфигурация с 0 и больше блоков, содержащая ключ subnet:
	config:
	- subnet: 172.28.0.0/16
	- subnet: 192.168.10.0/24

# Делает сеть изолированной
internal: true

# Использование сети, созданной вне Compose.
# Если параметр external имеет флаг true, то это указывает Compose, что сеть была создана извне. docker-compose up ее не создаст и если не найдет, то выкинет ошибку.
# external не может быть использован с другими ключами конфигурации (driver, driver_opts, ipam, internal)
external: true

# Для external можно задать имя для использования в Compose файле начиная с версии 3.5:
external:
	name: actual-name-of-network

# Так же с версии 3.5 можно задать имя сети даже с спецсимволами:
network1:
# Использование файла external так же работает в купе с заданным именем сети
external: true
name: my-app-net

# Метаданные для контейнера могут быть созданы с помощью Docker labels: это массив или словарь.
labels:
	com.example.description: "Financial transaction network"
	com.example.department: "Finance"
	com.example.label-with-empty-value: ""
```

**Network bridge (Сетевой мост)**

Network bridge (Сетевой мост) – это сетевое устройство, предназначенное для объединения сегментов сети передачи данных в единую сеть. Он работает на канальном (втором) уровне модели OSI (модели взаимодействия открытых систем). В отличие от концентратора, который работает на физическом уровне, сетевой мост не просто транслирует полученные с одного порта устройства на другие, а анализирует заголовок и отправляет на какой-либо один порт, либо не передает ни куда. Однако в отличие от маршрутизатора Network bridge не имеет таблицы маршрутизации и является само настраиваемым устройством и работает по заранее заложенным в нем принципам. Network bridge используется в нескольких сетевых технологиях, однако наибольшее распространение нашел в Ethernet.

Функции сетевого моста очень схожи с функциями другого сетевого устройства – switch (сетевой коммутатор). Фактически они выполняют одну и ту же задачу – объединение разрозненных сегментов и устройств сети в единую структуру. Главное отличие заключается в принципе работы, т.е. в том, как устройство узнает MAC-адреса устройств. После включения в сеть Network bridge анализирует поле "адрес источника» поступающих пакетов. Эту информацию он заносит в специальную таблицу. Отправляет он пакеты в соответствии с полем "адрес получателя» после анализа той же таблицы. Если там нет соответствия порта и MAC-адреса, то он направляет этот пакет во все исходящие порты. Если поле "адрес получателя» содержит MAC-адрес устройства, которое принадлежит той же сети, откуда поступил пакет, то он блокируется. Таким образом, мост блокирует пакеты, предназначенные для одного сегмента сети.

**Разница между режимами docker BRIDGE и HOST:**

Согласно документации docker о мостовой сети :

```
С точки зрения Docker, мостовая сеть использует программный мост, который позволяет контейнерам, подключенным к одной и той же мостовой сети, обмениваться данными, обеспечивая при этом изоляцию от контейнеров, которые не подключены к этой мостовой сети.
```

В соответствии с документацией docker о сети хостов:

```
Если вы используете сетевой драйвер хоста для контейнера, сетевой стек этого контейнера не изолирован от хоста Docker. Например, если вы запускаете контейнер, привязанный к порту 80, и используете сеть хоста, приложение контейнера будет доступно на порту 80 по адресу IP хоста.
```

Если вы хотите развернуть несколько контейнеров, соединенных между собой частной внутренней сетью, используйте мостовую сеть. Если вы хотите развернуть контейнер, подключенный к тому же сетевому стеку, что и хост (и получить доступ к тем же сетям, что и хост), используйте сеть хоста. Если вы просто хотите опубликовать некоторые порты , запустите контейнер с параметром --publish или -p , например -p 8080:80 .

**Работа с сетью (Networking) в Docker**

Сетевая Docker подсистема подключается используя драйверы. По умолчанию существует несколько драйверов которые обеспечивают основные сетевые функции:

 - bridge: Мост, — это сетевой драйвер по умолчанию. Бридж сеть используется, когда ваши приложения запускаются в автономных контейнерах, которые должны взаимодействовать между собой (Наглядный пример Nginx + MySQL).

 - host:  Хост, — это сетевой драйвер для автономных контейнеров (удаленная сетевая изоляция между контейнером и Docker хостом). Данный драйвер доступен только для docker-swarm с поддержкой Docker 17.06 и выше.

 - overlay/overlay2: Оверлей (Наложенная сеть), — это сетевой драйвер для соединения несколько демонов Docker между собой и которые позволяют  docker-swarm службам взаимодействовать друг с другом. Вы также можете использовать оверлейные сети для облегчения связи между docker-swarm и автономным контейнером или между двумя отдельными контейнерами на разных Docker демонах. Эта стратегия устраняет необходимость выполнения маршрутизации на уровне ОС между этими контейнерами.

 - macvlan: Маквлан,- это сетевой драйвер, который позволяют назначать MAC-адрес контейнеру, делая его отображаемым как физическое устройство в вашей сети. Docker демон направляет трафик на контейнеры по их MAC-адресам. Использование macvlan драйвера иногда является лучшим выбором при работе с устаревшими приложениями, которые ожидают, что они будут напрямую подключены к физической сети.

 - none: Нон,- это сетевой драйвер, который умеет отключать всю сеть для контейнеров. Обычно используется в сочетании с пользовательским сетевым драйвером.
 - Network plugins: Вы можете установить и использовать сторонние сетевые плагины с Docker контейнерами. Эти плагины доступны в Docker Store или у сторонних поставщиков услуг.

*Где и что лучше использовать?*

 - Мост (bridge) лучше всего использовать для связи  нескольких контейнеров на одном и том же Docker хосте. Можно юзать docker-compose и выберать даную сеть для такой связки.
 - Хост (host) сети лучше всего юзать, когда сетевой стек не должен быть изолирован от хоста Docker, но вы хотите, чтобы другие аспекты контейнера были изолированы.
 - Овердейная сеть (overlay/overlay2) или наложение сетей лучше всего заюзать, когда вам нужны контейнеры, работающие на разных Docker хостах для связи, или, когда несколько приложений работают вместе, используя docker-swarm.
 - Маквлан (macvlan) сети лучше всего использовать, когда вы переходите с VM/дедикейта  на контейнеры или хотите, чтобы ваши контейнеры выглядели как физические хосты в вашей сети, каждый с уникальным MAC-адресом.
 - Сторонние сетевые плагины позволяют интегрировать Docker со специализированными сетевыми стеками
